

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>GlobalBioIm Library’s documentation &mdash; GlobalBioIm Library 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="GlobalBioIm Library 0.1 documentation" href="#"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document"  style="text-align:justify">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
      <img src="logo.png"  width="300" />
        <div class="wy-side-nav-search">
          

          
            <a href="http://bigwww.epfl.ch/algorithms/globalbioim/" class="icon icon-home"> GlobalBioIm Library
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
<li><a class="reference internal" href="#">GlobalBioIm Library’s documentation</a></li>
<li><a class="reference internal" href="#linear-operators-linop">Linear Operators (LinOp)</a><ul>
<li><a class="reference internal" href="#linop-abstract-class">LinOp (abstract class)</a></li>
<li><a class="reference internal" href="#linopidentity">LinOpIdentity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cost-functions-cost">Cost Functions (Cost)</a><ul>
<li><a class="reference internal" href="#cost-abstract-class">Cost (abstract class)</a></li>
<li><a class="reference internal" href="#costl2">CostL2</a></li>
<li><a class="reference internal" href="#costl1">CostL1</a></li>
<li><a class="reference internal" href="#costkullleib">CostKullLeib</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimization-algorithms-opti">Optimization Algorithms (Opti)</a><ul>
<li><a class="reference internal" href="#opti-abstract-class">Opti (abstract class)</a></li>
<li><a class="reference internal" href="#optifbs">OptiFBS</a></li>
</ul>
</li>
</ul>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="#">GlobalBioIm Library</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="#">Docs</a> &raquo;</li>
      
    <li>GlobalBioIm Library’s documentation</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="globalbioim-library-s-documentation">
<h1>GlobalBioIm Library’s documentation<a class="headerlink" href="#globalbioim-library-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>This page contains detailled documentation of each function/class of the Library. The documentation is generated automatically from comments within M-files. It thus constitues the most up-to date documentation of the Library.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This page is under construction, not all the classes available in the library are detailed here yet.</p>
</div>
</div>
<div class="section" id="linear-operators-linop">
<h1>Linear Operators (LinOp)<a class="headerlink" href="#linear-operators-linop" title="Permalink to this headline">¶</a></h1>
<p>This section contains linear operator classes which all derive from the abstract class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Some methods defined in the main class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> are <strong>abstract</strong> which means that they need to be implemented in the derived classes. However, all the derived linear operators do not implement all these abstract methods. For example, if one implements a non-invertible linear operator, the method <code class="xref mat mat-meth docutils literal"><span class="pre">inverse()</span></code> do not have any sense and is thus not implemented for this linear operator. Hence, in the following, abstract methods which are <strong>not mentionned</strong> into the <strong>documentation</strong> of a derived linear operator are <strong>not implemented</strong> for this linear operator. Concerning the non-abstract methods of class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>, they are always inherited by all subclasses and are not mentionned in their respective documentation (except if there is a reimplementation for any reasons).</p>
</div>
<span class="target" id="module-LinOp"></span><div class="section" id="linop-abstract-class">
<h2>LinOp (abstract class)<a class="headerlink" href="#linop-abstract-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LinOp.LinOp">
<em class="property">class </em><code class="descclassname">LinOp.</code><code class="descname">LinOp</code><a class="headerlink" href="#LinOp.LinOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref mat mat-class docutils literal"><span class="pre">handle</span></code></p>
<p>Abstract class for linear operators
$$ \mathrm{H}: \mathrm{X}\rightarrow \mathrm{Y}.$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – name of the linear operator \(\mathbf{H}\)</li>
<li><strong>sizein</strong> – dimension of the left hand side vector space \(\mathrm{X}\)</li>
<li><strong>sizeout</strong> – dimension of the right hand side vector space \(\mathrm{Y}\)</li>
<li><strong>isinvertible</strong> – true if the operator is invertible</li>
<li><strong>iscomplex</strong> – true if the operator is complex</li>
<li><strong>norm</strong> – norm of the operator \(\|\mathrm{H}\|\) (if known, otherwise -1)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="LinOp.LinOp.HHt">
<code class="descname">HHt</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.HHt" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply \(\mathrm{H}\mathrm{H}^*\)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in Y\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= \mathrm{HH^*x}\)</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: There is a default implementation in the abstract class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> which calls successively the <a class="reference internal" href="#LinOp.LinOp.adjoint" title="LinOp.LinOp.adjoint"><code class="xref mat mat-meth docutils literal"><span class="pre">adjoint()</span></code></a> and <a class="reference internal" href="#LinOp.LinOp.apply" title="LinOp.LinOp.apply"><code class="xref mat mat-meth docutils literal"><span class="pre">apply()</span></code></a> methods. However, it can be reimplemented in derived classes if there exists a faster way to perform computation.</p>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.HtH">
<code class="descname">HtH</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.HtH" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply \(\mathrm{H}^*\mathrm{H}\)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in X\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= \mathrm{H^*Hx}\)</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: There is a default implementation in the abstract class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> which calls successively the <a class="reference internal" href="#LinOp.LinOp.apply" title="LinOp.LinOp.apply"><code class="xref mat mat-meth docutils literal"><span class="pre">apply()</span></code></a> and <a class="reference internal" href="#LinOp.LinOp.adjoint" title="LinOp.LinOp.adjoint"><code class="xref mat mat-meth docutils literal"><span class="pre">adjoint()</span></code></a> methods. However, it can be reimplemented in derived classes if there exists a faster way to perform computation.</p>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.adjoint">
<code class="descname">adjoint</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>(Abstract method)</strong> Apply the adjoint of the linear operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in Y\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= \mathrm{H^*x}\) where \(\mathrm{H}^*\) is defined such that $$\langle\mathrm{Hx},\mathrm{y}\rangle_{\mathrm{Y}} = \langle \mathrm{x}, \mathrm{H}^*\mathrm{y} \rangle_{\mathrm{X}}$$</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.apply" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>(Abstract method)</strong> Apply the linear operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in X\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= \mathrm{Hx}\)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.ctranspose">
<code class="descname">ctranspose</code><span class="sig-paren">(</span><em>this</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.ctranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload operator (‘) for <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> objects (i.e. <a class="reference internal" href="#LinOp.LinOp.adjoint" title="LinOp.LinOp.adjoint"><code class="xref mat mat-meth docutils literal"><span class="pre">adjoint()</span></code></a>).</p>
<p><strong>Note</strong>: operators (‘) and (.’) (see <a class="reference internal" href="#LinOp.LinOp.transpose" title="LinOp.LinOp.transpose"><code class="xref mat mat-meth docutils literal"><span class="pre">transpose()</span></code></a>) are identical for <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>thisx</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>(Abstract method)</strong> Apply \(\mathrm{H}^{-1}\) (if applicable)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in Y\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= \mathrm{H^{-1}x}\)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.mtimes">
<code class="descname">mtimes</code><span class="sig-paren">(</span><em>this</em>, <em>H2</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.mtimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload operator (*) for <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> objects.
$$ \mathrm{H}_{new} =  \mathrm{H_2} \mathrm{H}$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>H2</strong> – <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> object or a scalar in \(\mathbb{R}\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns Hnew:</th><td class="field-body"><a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.plus">
<code class="descname">plus</code><span class="sig-paren">(</span><em>this</em>, <em>H2</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload operator (+) for <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> objects.
$$ \mathrm{H}_{new} =  \mathrm{H_2} + \mathrm{H}$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>H2</strong> – <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns Hnew:</th><td class="field-body"><a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOp.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>this</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOp.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload operator (.’) for <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> objects (i.e. <a class="reference internal" href="#LinOp.LinOp.adjoint" title="LinOp.LinOp.adjoint"><code class="xref mat mat-meth docutils literal"><span class="pre">adjoint()</span></code></a>).</p>
<p><strong>Note</strong>: operators (.’) and (‘) (see <a class="reference internal" href="#LinOp.LinOp.ctranspose" title="LinOp.LinOp.ctranspose"><code class="xref mat mat-meth docutils literal"><span class="pre">ctranspose()</span></code></a>) are identical for <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="linopidentity">
<h2>LinOpIdentity<a class="headerlink" href="#linopidentity" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LinOp.LinOpIdentity">
<em class="property">class </em><code class="descclassname">LinOp.</code><code class="descname">LinOpIdentity</code><span class="sig-paren">(</span><em>sz</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOpIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#LinOp.LinOp" title="LinOp.LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp.LinOp</span></code></a></p>
<p>Identity operator
$$\mathrm{H} : \mathrm{x} \mapsto \mathrm{x}$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sz</strong> – size of \(mathrm{x}\) on which the <a class="reference internal" href="#LinOp.LinOpIdentity" title="LinOp.LinOpIdentity"><code class="xref mat mat-class docutils literal"><span class="pre">LinOpIdentity</span></code></a> applies.</td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a></p>
<dl class="method">
<dt id="LinOp.LinOpIdentity.HHt">
<code class="descname">HHt</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOpIdentity.HHt" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOpIdentity.HtH">
<code class="descname">HtH</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOpIdentity.HtH" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOpIdentity.adjoint">
<code class="descname">adjoint</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOpIdentity.adjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOpIdentity.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOpIdentity.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="LinOp.LinOpIdentity.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#LinOp.LinOpIdentity.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="cost-functions-cost">
<h1>Cost Functions (Cost)<a class="headerlink" href="#cost-functions-cost" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>This section contains cost functions classes which all derive from the abstract class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Some methods defined in the main class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> are <strong>abstract</strong> which means that they need to be implemented in the derived classes. However, all the derived costs do not implement all these abstract methods. For example, if one implements a non-differentiable cost, the method <code class="xref mat mat-meth docutils literal"><span class="pre">grad()</span></code> do not have any sense and is thus not implemented for this cost. Hence, in the following, abstract methods which are <strong>not mentionned</strong> into the <strong>documentation</strong> of a derived cost are <strong>not implemented</strong> for this cost. Concerning the non-abstract methods of class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>, they are always inherited by all subclasses and are not mentionned in their respective documentation (except if there is a reimplementation for any reasons).</p>
</div>
<span class="target" id="module-Cost"></span><div class="section" id="cost-abstract-class">
<h2>Cost (abstract class)<a class="headerlink" href="#cost-abstract-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Cost.Cost">
<em class="property">class </em><code class="descclassname">Cost.</code><code class="descname">Cost</code><a class="headerlink" href="#Cost.Cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref mat mat-class docutils literal"><span class="pre">handle</span></code></p>
<p>Abstract class for Cost functions
$$ C : \mathrm{X} \longrightarrow \mathbb{R}$$
with the following special structure
$$ C(\mathrm{x}) := F( \mathrm{Hx} , \mathrm{y} ) $$
where \(F\) is a function takin two variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>H</strong> – a <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> object (default <code class="xref mat mat-class docutils literal"><span class="pre">LinOpIdentity</span></code>)</li>
<li><strong>y</strong> – data vector of size H.sizeout (default 0)</li>
<li><strong>name</strong> – name of the cost function</li>
<li><strong>lip</strong> – Lipschitz constant of the gradient (when applicable and known, otherwise -1)</li>
<li><strong>isconvex</strong> – boolean true is the function is convex</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a>.</p>
<dl class="method">
<dt id="Cost.Cost.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.eval" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>(Abstract Method)</strong> Evaluates the cost function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in \mathrm{X}\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= C(\mathrm{x})\)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.eval_grad">
<code class="descname">eval_grad</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.eval_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates both the cost function and its gradient (when applicable)</p>
<p><strong>Note</strong>: For some derived classes this function is reimplemented in a faster way than running both <a class="reference internal" href="#Cost.Cost.eval" title="Cost.Cost.eval"><code class="xref mat mat-meth docutils literal"><span class="pre">eval()</span></code></a> and <a class="reference internal" href="#Cost.Cost.grad" title="Cost.Cost.grad"><code class="xref mat mat-meth docutils literal"><span class="pre">grad()</span></code></a> successively (default).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in \mathrm{X}\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= \left[C(\mathrm{x}), \nabla C(\mathrm{x})\right]\)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.grad">
<code class="descname">grad</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.grad" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>(Abstract Method)</strong> Evaluates the gradient of the cost function (when applicable)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> – \(\in \mathrm{X}\)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body">\(= \nabla C(\mathrm{x})\)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.minus">
<code class="descname">minus</code><span class="sig-paren">(</span><em>this</em>, <em>C2</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload operator (-) for <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> objects
$$ C_{new}(\mathrm{x}) := C(\mathrm{x}) - C_2(\mathrm{x})$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>C2</strong> – <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns Cnew:</th><td class="field-body"><a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>See also: <code class="xref mat mat-class docutils literal"><span class="pre">SumCost</span></code></p>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.mtimes">
<code class="descname">mtimes</code><span class="sig-paren">(</span><em>this</em>, <em>C2</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.mtimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload operator (-) for <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> objects
$$ C_{new}(\mathrm{x}) := C(\mathrm{x}) \times C_2(\mathrm{x})$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>C2</strong> – <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> object or a scalar in \(\mathbb{R}\).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns Cnew:</th><td class="field-body"><a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>See also: <code class="xref mat mat-class docutils literal"><span class="pre">MultCost</span></code></p>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.o">
<code class="descname">o</code><span class="sig-paren">(</span><em>this</em>, <em>L</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.o" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose the cost \(C\) with a <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> \(\mathrm{L}\)
$$ C_{new}(\mathrm{x}) := C(\mathrm{Lx}) $$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>L</strong> – <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a> object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns Cnew:</th><td class="field-body">the new <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>See also: <code class="xref mat mat-class docutils literal"><span class="pre">ComposeLinOpCost</span></code></p>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.plus">
<code class="descname">plus</code><span class="sig-paren">(</span><em>this</em>, <em>C2</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload operator (+) for <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> objects
$$ C_{new}(\mathrm{x}) := C(\mathrm{x}) + C_2(\mathrm{x})$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>C2</strong> – <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> object.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns Cnew:</th><td class="field-body"><a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>See also: <code class="xref mat mat-class docutils literal"><span class="pre">SumCost</span></code></p>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.prox">
<code class="descname">prox</code><span class="sig-paren">(</span><em>this</em>, <em>x</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.prox" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>(Abstract Method)</strong> Evaluates the proximity operator of the cost (when applicable)
$$ \mathrm{prox}_{\alpha C}(\mathrm{x}) =  \mathrm{arg} \, \mathrm{min}_{\mathrm{u} \in \mathrm{X}} \; \frac{1}{2\alpha} \| \mathrm{u} - \mathrm{x} \|_2^2 + C(\mathrm{u}). $$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – \(\in \mathrm{X}\)</li>
<li><strong>alpha</strong> – \(\in \mathbb{R}\)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body"><p class="first last">\(= \mathrm{prox}_{\alpha C}(\mathrm{x})\)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Cost.Cost.prox_fench">
<code class="descname">prox_fench</code><span class="sig-paren">(</span><em>this</em>, <em>x</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.Cost.prox_fench" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the proximity operator of the Fenchel Transform \(C^*\) (when applicable) which is computed using Moreau’s identity:
$$\mathrm{prox}_{\alpha C^*}(\mathrm{x}) = \mathrm{x} - \alpha \,\mathrm{prox}_{\frac{1}{\alpha}C}\left(\frac{\mathrm{x}}{\alpha}\right).$$
<strong>Note-1</strong>: Only defined if <code class="xref mat mat-attr docutils literal"><span class="pre">isconvex</span></code> =True.</p>
<p><strong>Note-2</strong> When defining a new class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>, one only requires to implements the prox.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – \(\in \mathrm{X}\)</li>
<li><strong>alpha</strong> – \(\in \mathbb{R}\)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns y:</th><td class="field-body"><p class="first last">\(= \mathrm{prox}_{\alpha C^*}(\mathrm{x})\)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="costl2">
<h2>CostL2<a class="headerlink" href="#costl2" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Cost.CostL2">
<em class="property">class </em><code class="descclassname">Cost.</code><code class="descname">CostL2</code><span class="sig-paren">(</span><em>H</em>, <em>y</em>, <em>wght</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Cost.Cost" title="Cost.Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost.Cost</span></code></a></p>
<p>Weighted L2 norm cost function
$$C(\mathrm{x}) := \frac12\|\mathrm{Hx} - \mathrm{y}\|^2_W $$</p>
<p>All attributes of parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> are inherited.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>W</strong> – weighting <code class="xref mat mat-class docutils literal"><span class="pre">LinOpDiag</span></code> object or scalar (default <code class="xref mat mat-class docutils literal"><span class="pre">LinOpIdentity</span></code>)</td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a></p>
<dl class="method">
<dt id="Cost.CostL2.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostL2.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Cost.CostL2.grad">
<code class="descname">grad</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostL2.grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.
$$ \nabla C(\mathrm{x}) = \mathrm{H^* W (Hx - y)} $$
It is L-Lipschitz continuous with \( L \leq \|\mathrm{H}\|^2 \|\mathrm{W}\|\).</p>
</dd></dl>

<dl class="method">
<dt id="Cost.CostL2.prox">
<code class="descname">prox</code><span class="sig-paren">(</span><em>this</em>, <em>x</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostL2.prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> if</p>
<ul class="simple">
<li>the operator <code class="xref mat mat-attr docutils literal"><span class="pre">H</span></code>  is a <code class="xref mat mat-class docutils literal"><span class="pre">LinOpIdentity</span></code>,</li>
</ul>
<p>$$\mathrm{prox}_{\alpha C}(\mathrm{x}) = \frac{\mathrm{x}+\alpha \mathrm{W}\mathrm{y}}{1+\alpha \mathrm{W}}$$
where the division is component-wise.</p>
<ul class="simple">
<li>the operator <code class="xref mat mat-attr docutils literal"><span class="pre">H</span></code>  is a <code class="xref mat mat-class docutils literal"><span class="pre">LinOpConv</span></code> and <code class="xref mat mat-attr docutils literal"><span class="pre">W</span></code>  is a <code class="xref mat mat-class docutils literal"><span class="pre">LinOpIdentity</span></code>;</li>
</ul>
<p>$$\mathrm{prox}_{\alpha C}(\mathrm{x}) = \mathcal{F}^{-1}\left(\frac{\mathcal{F}(\mathrm{x}) + \alpha  \mathcal{F}(\mathrm{H}^*)\mathcal{F}(\mathrm{y})  }{1+\alpha \vert\mathcal{F}(\mathrm{H})\vert^2} \right)$$
where \(\mathcal{F} \) stands for the Fourier transform.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="costl1">
<h2>CostL1<a class="headerlink" href="#costl1" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Cost.CostL1">
<em class="property">class </em><code class="descclassname">Cost.</code><code class="descname">CostL1</code><span class="sig-paren">(</span><em>H</em>, <em>y</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Cost.Cost" title="Cost.Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost.Cost</span></code></a></p>
<p>L1 norm cost function
$$C(x) := \|\mathrm{Hx} - \mathrm{y}\|_1 $$</p>
<p>All attributes of parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> are inherited.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nonneg</strong> – boolean (varargin parameter) to combine a nonnegativity constraint to the cost (default false).</td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a></p>
<dl class="method">
<dt id="Cost.CostL1.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostL1.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Cost.CostL1.prox">
<code class="descname">prox</code><span class="sig-paren">(</span><em>this</em>, <em>x</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostL1.prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> if the operator <code class="xref mat mat-attr docutils literal"><span class="pre">H</span></code>  is invertible.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="costkullleib">
<h2>CostKullLeib<a class="headerlink" href="#costkullleib" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Cost.CostKullLeib">
<em class="property">class </em><code class="descclassname">Cost.</code><code class="descname">CostKullLeib</code><span class="sig-paren">(</span><em>H</em>, <em>y</em>, <em>bet</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostKullLeib" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Cost.Cost" title="Cost.Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost.Cost</span></code></a></p>
<p>KullbackLeibler divergence
$$ C(\mathrm{x}) :=\sum_n D_{KL}((\mathrm{Hx})_n)$$
where
$$ D_{KL}(\mathrm{z}_n) := \left\lbrace \begin{array}[ll]
\mathrm{z}_n - \mathrm{y}_n \log(\mathrm{z}_n + \beta) &amp; \text{ if } \mathrm{z}_n + \beta &gt;0  \newline
+ \infty &amp;  \text{otherwise}.
\end{array} \right.$$</p>
<p>All attributes of parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> are inherited.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bet</strong> – smoothing parameter \(\beta\) (default 0)</td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> <a class="reference internal" href="#module-LinOp" title="LinOp"><code class="xref mat mat-class docutils literal"><span class="pre">LinOp</span></code></a></p>
<dl class="method">
<dt id="Cost.CostKullLeib.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostKullLeib.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Cost.CostKullLeib.grad">
<code class="descname">grad</code><span class="sig-paren">(</span><em>this</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostKullLeib.grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Cost.CostKullLeib.prox">
<code class="descname">prox</code><span class="sig-paren">(</span><em>this</em>, <em>x</em>, <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#Cost.CostKullLeib.prox" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplemented from parent class <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="optimization-algorithms-opti">
<h1>Optimization Algorithms (Opti)<a class="headerlink" href="#optimization-algorithms-opti" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div>This section contains optimization algorithms classes which all derive from the abstract class <a class="reference internal" href="#module-Opti" title="Opti"><code class="xref mat mat-class docutils literal"><span class="pre">Opti</span></code></a>.</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <code class="xref mat mat-meth docutils literal"><span class="pre">run()</span></code> method defined in the main class <a class="reference internal" href="#module-Opti" title="Opti"><code class="xref mat mat-class docutils literal"><span class="pre">Opti</span></code></a> is <strong>abstract</strong> and has to be implemented in any derived class.</p>
</div>
<span class="target" id="module-Opti"></span><div class="section" id="opti-abstract-class">
<h2>Opti (abstract class)<a class="headerlink" href="#opti-abstract-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Opti.Opti">
<em class="property">class </em><code class="descclassname">Opti.</code><code class="descname">Opti</code><a class="headerlink" href="#Opti.Opti" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref mat mat-class docutils literal"><span class="pre">matlab.mixin.SetGet</span></code></p>
<p>Abstract class for optimization algorithms to minimize <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – name of the algorithm</li>
<li><strong>cost</strong> – minimized <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a></li>
<li><strong>maxiter</strong> – maximal number of iterations (default 50)</li>
<li><strong>xtol</strong> – tolerance on the relative difference between two iterates (default 1e-5)</li>
<li><strong>OutOp</strong> – <code class="xref mat mat-class docutils literal"><span class="pre">OutputOpti</span></code> object</li>
<li><strong>ItUpOut</strong> – number of iterations between two calls to the update method of the  <code class="xref mat mat-class docutils literal"><span class="pre">OutputOpti</span></code> object <code class="xref mat mat-attr docutils literal"><span class="pre">OutOp</span></code> (default 0)</li>
<li><strong>time</strong> – execution time of the algorithm</li>
<li><strong>niter</strong> – iteration counter</li>
<li><strong>xopt</strong> – optimization variable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See also <code class="xref mat mat-class docutils literal"><span class="pre">OutputOpti</span></code> <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a></p>
<dl class="method">
<dt id="Opti.Opti.ending_verb">
<code class="descname">ending_verb</code><span class="sig-paren">(</span><em>this</em><span class="sig-paren">)</span><a class="headerlink" href="#Opti.Opti.ending_verb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic method to display a ending message in verbose mode.</p>
</dd></dl>

<dl class="method">
<dt id="Opti.Opti.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>this</em>, <em>x0</em><span class="sig-paren">)</span><a class="headerlink" href="#Opti.Opti.run" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>(Abstract method)</strong> Run the algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x0</strong> – initial point in \(\in X\), if x0=[] restarts from the current value <code class="xref mat mat-attr docutils literal"><span class="pre">xopt</span></code>.</td>
</tr>
</tbody>
</table>
<p><strong>note</strong>: this method does not return anything, the result being stored in public attribute <code class="xref mat mat-attr docutils literal"><span class="pre">xopt</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="Opti.Opti.starting_verb">
<code class="descname">starting_verb</code><span class="sig-paren">(</span><em>this</em><span class="sig-paren">)</span><a class="headerlink" href="#Opti.Opti.starting_verb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic method to display a starting message in verbose mode.</p>
</dd></dl>

<dl class="method">
<dt id="Opti.Opti.test_convergence">
<code class="descname">test_convergence</code><span class="sig-paren">(</span><em>this</em>, <em>xold</em><span class="sig-paren">)</span><a class="headerlink" href="#Opti.Opti.test_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests algorithm convergence from the relative difference between two successive iterates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>xold</strong> – iterate \( \mathrm{x}^{k-1}\).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns stop:</th><td class="field-body">boolean true if</td>
</tr>
</tbody>
</table>
<p>$$ \frac{\| \mathrm{x}^{k} - \mathrm{x}^{k-1}\|}{\|\mathrm{x}^{k-1}\|} &lt; x_{tol}.$$</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="optifbs">
<h2>OptiFBS<a class="headerlink" href="#optifbs" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Opti.OptiFBS">
<em class="property">class </em><code class="descclassname">Opti.</code><code class="descname">OptiFBS</code><span class="sig-paren">(</span><em>F</em>, <em>G</em>, <em>OutOp</em><span class="sig-paren">)</span><a class="headerlink" href="#Opti.OptiFBS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#Opti.Opti" title="Opti.Opti"><code class="xref mat mat-class docutils literal"><span class="pre">Opti.Opti</span></code></a></p>
<p>Forward-Backward Splitting optimization algorithm [1] which minimizes <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> of the form
$$ C(\mathrm{x}) = F(\mathrm{x}) + G(\mathrm{x}) $$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>F</strong> – a differentiable <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> (i.e. with an implementation of <code class="xref mat mat-meth docutils literal"><span class="pre">grad()</span></code>).</li>
<li><strong>G</strong> – a <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a> with an implementation of the <code class="xref mat mat-meth docutils literal"><span class="pre">prox()</span></code>.</li>
<li><strong>gam</strong> – descent step</li>
<li><strong>fista</strong> – boolean true if the accelerated version FISTA [3] is used (default false)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: When the functional are convex and F has a Lipschitz continuous gradient, convergence is
ensured by taking \(\gamma \in (0,2/L] \) where \(L\) is the Lipschitz constant of \(\nabla F\) (see [1]).
When FISTA is used [3], \(\gamma \) should be in \((0,1/L]\). For nonconvex functions [2] take \(\gamma \in (0,1/L]\).    
If \(L\) is known (i.e. F.lip different from -1), parameter \(\gamma\) is automatically set to \(1/L\).</p>
<p><strong>References</strong>:</p>
<p>[1] P.L. Combettes and V.R. Wajs, “Signal recovery by proximal forward-backward splitting”, SIAM Journal on
Multiscale Modeling &amp; Simulation, vol 4, no. 4, pp 1168-1200, (2005).</p>
<p>[2] Hedy Attouch, Jerome Bolte and Benar Fux Svaiter “Convergence of descent methods for semi-algebraic and 
tame problems: proximal algorithms, forward-backward splitting, and regularized gaussiedel methods.” 
Mathematical Programming, 137 (2013).</p>
<p>[3] Amir Beck and Marc Teboulle, “A Fast Iterative Shrinkage-Thresholding Algorithm for Linear inverse Problems”,
SIAM Journal on Imaging Science, vol 2, no. 1, pp 182-202 (2009)</p>
<p>See also <a class="reference internal" href="#module-Opti" title="Opti"><code class="xref mat mat-class docutils literal"><span class="pre">Opti</span></code></a> <code class="xref mat mat-class docutils literal"><span class="pre">OutputOpti</span></code> <a class="reference internal" href="#module-Cost" title="Cost"><code class="xref mat mat-class docutils literal"><span class="pre">Cost</span></code></a></p>
<dl class="method">
<dt id="Opti.OptiFBS.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>this</em>, <em>x0</em><span class="sig-paren">)</span><a class="headerlink" href="#Opti.OptiFBS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Reimplementation from <a class="reference internal" href="#module-Opti" title="Opti"><code class="xref mat mat-class docutils literal"><span class="pre">Opti</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Biomedical Imaging Group (EPFL).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>
